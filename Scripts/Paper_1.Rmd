---
title: "ICM testing"
output:
  pdf_document: default
  html_document: default
  word_document: 
    #reference_docx: template.docx
editor_options:
  chunk_output_type: console
---

The data is now available to test this on at least 81 stocks.  All of the NE Atlantic stocks (ICES) have been through the QA/QC process and we are happy with those data (Sept 1, 2022).  Let's see if we can get this to work on all the stocks with sufficient data... 

```{r, load-stuff,echo=F, message=F, warning=F, fig.width=6, fig.height=4}
# OK, so using the ICES assessments here's what we get for North Sea cod.
library(readxl)
library(tidyverse)
library(rio)
library(ggthemes)
library(cowplot)
loc <- 'D:/GitHub/ICM'

source(paste0(loc,"/Scripts/functions/tuning_sim_fast.R"))

# Choose 5 ICES stocks that we have the necessary data for
#ASR <- read_xlsx("../Data/ASR_2018.xlsx" sheet = "ICES")
ASR1 <- read.csv(paste0(loc,"/Data/ICM_data_NE_atlantic_stocks.csv"))
ASR <- read.csv(paste0(loc,"/Data/ICM_data_NW_atlantic_stocks.csv"))



ASR <- rbind(ASR1,ASR)
datatypes <- unique(gsub(x = names(ASR), pattern = "[^a-zA-Z]", replacement=""))

# Replace 0's in Num.tot with NA so the rest of this works as Freya designed it to...
ASR$Num.tot[ASR$Num.tot == 0] <- NA
# we want:
# Year, Num, WA, Catch, AM, NM, StockID, Management, Area, Order, Family, Genus, Species
ASRdat <- ASR[,c(grep(x=names(ASR), "Num"),
                 grep(x=names(ASR), "WA"),
                 grep(x=names(ASR), "Catch"),
                 grep(x=names(ASR), "AM"),
                 grep(x=names(ASR), "NM"))]
# Making all the data numeric that should be numeric
ASRdat <- apply(X = ASRdat, 2, as.numeric)
# Getting the species info back
ASRsp <- ASR[, which(!1:length(names(ASR)) %in% grep(x=names(ASR), ".", fixed=T))]
# And binding it all back together
ASR_trim <- cbind(ASRsp, ASRdat)
# need a unique ID for stock
#table(ASR_trim$Management, ASR_trim$Species)
ASR_trim$Stock <- paste0(ASR_trim$Management, "_", ASR_trim$Area, "_", ASR_trim$Genus, "_", ASR_trim$Species)

ASR_long <- ASR_trim %>%
  pivot_longer(!c("Management", "Area", "Order", "Family", "Genus", "Species", "Stock", "Year","Meeting_or_reference","Model","Case","Notes")) %>%
  separate(col=name, into=c("type", "age"), sep = "\\.")

# Something is weird with the mentella stock, I'm going to drop it...
ASR_long <- ASR_long %>% dplyr::filter(Stock != "ICES-AFWG_DEEP1-2_Sebastes_mentella")

```

```{r, prep-data,echo=F, message=F, warning=F, fig.width=6, fig.height=4}

Stocks <- ASR_long %>%
                    dplyr::filter(!is.na(value)) %>%
                    dplyr::group_by(Stock, type) %>%
                    dplyr::summarize(count=length(unique(value))) %>%
                    dplyr::group_by(Stock) %>%
                    dplyr::summarize(types=length(unique(type))) %>%
                    dplyr::filter(types==5) %>%
                    dplyr::select(Stock)

ASR_stocks <- ASR_long %>%
                        dplyr::filter(Stock %in% Stocks$Stock) %>%
                        dplyr::filter(!is.na(value)) %>%
                        dplyr::arrange(Stock, Year, type, as.numeric(age))

# Stocks <- ASR_stocks %>%
#                       dplyr::group_by(Stock, Species, type) %>%
#                       dplyr::summarize(ages=length(unique(age)),
#                                 years=length(unique(Year))) %>%
#                       dplyr::arrange(-years, -ages) %>%
#                       dplyr::filter(!Species=="morhua") %>%
#                       dplyr::distinct(Stock) %>%
#                       dplyr::pull(Stock)
# 
# print(Stocks)
Stocks <- Stocks$Stock

# Going to remove Sebastes norvegicus because we can't get fecundity as the only data we have is total numbers.
#Stocks <- Stocks[Stocks != "ICES-AFWG_DEEP1-2_Sebastes_norvegicus"]
# Esmarki doesn't work great as it is assessed using a quarterly model.
#Stocks <- Stocks[Stocks != "ICES-WGNSSK_NS 4-3aN_Trisopterus_esmarkii"]
#i = 'ICES-AFWG_NEA1-2_Melanogrammus_aeglefinus'
years.tmp <- NULL
pnm.tmp <- NULL
waa.tmp <- NULL
ages.tmp <- NULL
rem.tmp <- NULL
mx.tmp <- NULL
NE.tmp <- NULL
vpa.tmp <- NULL
am.tmp <- NULL
mr.tmp <- NULL
all.abund.tmp <- NULL
full.abund.tmp <- NULL
full.rem.tmp <- NULL
fs.tmp <- NULL
for(i in Stocks)
{
  print(i)
  ASR_sub <- ASR_long %>%
    dplyr::select(Year, Stock, type, age, value) %>%
    dplyr::filter(Stock==i)

  # Drop the NA years....
  if(i == "ICES-NWWG_ICE-Summer_Clupea_harengus") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1986)
  # There's some funkiness going on in the first 7 years of these data, so staring in year 8
  if( i == "ICES-WGNSSK_NS  4-6a-20_Melanogrammus_aeglefinus") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1971)
  if(i == "ICES-NWWG_FA5b_Pollachius_virens") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1982)
  if(i == "ICES-NWWG_FA5a_Pollachius_virens") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1984)
  if(i == "ICES-AFWG_NEA1-2_Pollachius_virens") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1969)
  if(i == "ICES-WGCSE_CS27.6a_Merlangius_merlangus") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1980)
  if(i == "ICES-WGCSE_NS6a_Gadus_morhua") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1980)
  if(i == "ICES-AFWG_COASTNOR 1-2_Gadus_morhua") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 2006)
  if(i == "NEFSC_5Z_Pseudopleuronectes_americanus") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1982)
  if(i == "ICES-WGNSSK_NS 4-7d_Merlangius_merlangus") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1989)
  
  # maxage <- max(as.numeric(ASR_sub$age[!is.na(ASR_sub$value)]))
  # maxYear <- max(ASR_sub$Year[!is.na(ASR_sub$value)])
  # minYear <- min(ASR_sub$Year[!is.na(ASR_sub$value)])
  # forplot <- ASR_sub[as.numeric(ASR_sub$age) < (maxage+1) & ASR_sub$Year %in% minYear:maxYear,]
  # 
  # # summary plots
  # print(ggplot() + geom_line(data=forplot, aes(Year, value)) + facet_grid(type~as.numeric(age), scales="free_y") +
  #         geom_vline(data=forplot[is.na(forplot$value),], aes(xintercept=Year), colour="red") + facet_grid(type~as.numeric(age), scales="free_y") +
  #         theme_bw() + 
  #         ggtitle(i)
  # )
  
  age.mat <- ASR_sub %>% dplyr::filter(type=="AM") %>% dplyr::rename(AM=value) %>% dplyr::select(-type)
  # All of the age at maturities are NA in 0 and 1 year olds, so make them 0's, do that carefully just
  # in case that changes later...
  am.0s <- length(which((!is.na(age.mat$AM[age.mat$age ==0]))))
  am.1s <- length(which((!is.na(age.mat$AM[age.mat$age ==1]))))
  am.2s <- length(which((!is.na(age.mat$AM[age.mat$age ==2]))))
  am.3s <- length(which((!is.na(age.mat$AM[age.mat$age ==3]))))
  if(am.0s == 0) age.mat$AM[age.mat$age ==0] <- 0
  if(am.1s == 0) age.mat$AM[age.mat$age ==1] <- 0
  if(am.2s == 0) age.mat$AM[age.mat$age ==2] <- 0
  if(am.3s == 0) age.mat$AM[age.mat$age ==3] <- 0
  
   # Now we can get the abundance from the VPA models
  abund <- ASR_sub %>% dplyr::filter(type=="Num") %>% dplyr::rename(Num=value) %>% dplyr::select(-type)
  
  #if(am.1s | am.0s | am.2s > 0) print("Stop, you need to check the age at maturity for either age 0 or 1 as there is data in there.")
  # Now do something similar for the Natural moralities, but in this case
  # we take the NM of the youngest age class we have information for and back that number up to year 0.
  # DK NOTE:  THIS IS A BIG CHANGE IN DIRECTION FOR THE LOTKA CALCS SO NEED TO NOTE THIS ONE!!
  
  
  nm.tmp <-  ASR_sub %>% dplyr::filter(type=="NM") %>% dplyr::rename(NM=value) %>% dplyr::select(-type)
  
  #minage
  minage <- min(as.numeric(nm.tmp$age[!is.na(nm.tmp$NM)]))
  if(minage == 0)  nat.mort <- nm.tmp
  # Some specials...
  if(i %in% c("ICES-WGCSE_CS7e-k_Gadus_morhua","ICES-WGCSE_ROCK6b_Melanogrammus_aeglefinus",
              "ICES-WGHANSA_SP8abd_Sardina _pilchardus","ICES-WGWIDE_NEA 1-9,12,14_Micromesistius_poutassou")) minage <- 1
  if(i == "ICES-WGWIDE_NEA 1,2,5,4a,14a_clupea_ harengus") minage <- 2
  #maxage
  maxage <- max(as.numeric(nm.tmp$age[!is.na(nm.tmp$NM)]))
  
  # Now get the number of individuals in the youngest age category
  num.age.min <- ASR_sub %>% dplyr::filter(age==minage,type=="Num")
  # So any Recruitment even that is > 3 SE's away from the median I'm calling 
  # an 'extreme' recruitment event and it is going to get a lower/higher natural mortality term.
  med.mun.age.min <- mean(num.age.min$value,na.rm=T)
  sd.mun.age.min <- sd(num.age.min$value,na.rm=T)#/sqrt(length(na.omit(num.age.min$value)))
  low.rec <- med.mun.age.min - 2*sd.mun.age.min
  high.rec <- med.mun.age.min + 2*sd.mun.age.min
  high.rec.years <- as.vector(na.omit(num.age.min$Year[num.age.min$value > high.rec]))
  low.rec.years <- as.vector(na.omit(num.age.min$Year[num.age.min$value < low.rec]))
  # Set up the full abundance matrix 
  full.abund <- abund
  print(paste0("Stock ", i , ' high recruit years include ', length(c(low.rec.years,high.rec.years)), ' years'))
  # If we need to imput some data run this loop for natural mortality
  if(minage == 0) full.abund <- abund
  

  if(minage > 0)
  {
    yrs <- sort(unique((nm.tmp$Year)))
    nm.res <- NULL
    # These already have NM estimates at 0 so don't need to do them...
    if(!i %in% c("ICES-WGCSE_CS7e-k_Gadus_morhua","ICES-WGCSE_ROCK6b_Melanogrammus_aeglefinus",
                 "ICES-WGHANSA_SP8abd_Sardina _pilchardus","ICES-WGWIDE_NEA 1,2,5,4a,14a_clupea_ harengus",
                 "ICES-WGWIDE_NEA 1-9,12,14_Micromesistius_poutassou"))
    {
      # Just use the mean mortality of the youngest age class we have information for
      nm.use <- mean(nm.tmp$NM[nm.tmp$age==minage],na.rm=T)
      # Take the average natural mortality of the youngest age class with an m and use that
      # This avoids really blowing up the abundance in the younger age classes which can get a bit squirrly
      # nm.high.rec <- 0.5*(min(nm.tmp$NM[nm.tmp$age==minage],na.rm=T))
      # nm.low.rec <-  1.5*(max(nm.tmp$NM[nm.tmp$age==minage],na.rm=T))
      # Start by filling in everything...
      nm.tmp$NM[is.na(nm.tmp$NM)] <- nm.use
      nm.tmp <- nm.tmp[nm.tmp$age %in% 0:maxage,]
      # Now we need to fill in the 'special' cohorts that were really big (low m) or really small (high m)
      # for(y in length(yrs):1)
      # {
      #   if(yrs[y] %in% c(high.rec.years,low.rec.years))
      #   {
      #     if(yrs[y] %in% high.rec.years) nm.pick <- nm.high.rec
      #     if(yrs[y] %in% low.rec.years) nm.pick <- nm.low.rec
      #     for(a in minage:1) nm.tmp$NM[nm.tmp$Year == (yrs[y]-a) & nm.tmp$age == minage-a] <- nm.pick
      # }} #Close the if and for loops
      # Pointless rename...
    } #end the skip the stocks with nm at 0 if
      nat.mort <- nm.tmp
      
  # Now do the same loopiness for abundance
    for(y in length(yrs):2)
    {
      # The minage of the natural mortality is different from minage of the abundance, annoyingly for this stock...
      if(i == "ICES-AFWG_NEA1-2_Gadus_morhua") minage <- 3
      if(i == "ICES-NWWG_ICE-Summer_Clupea_harengus") minage <- 3

           # The lowest minage =4, This goes first since we go backwards, this gets us age 3 in year 3
           if(minage ==4) 
           {
               four.abund <- full.abund %>% dplyr::filter(Year == yrs[y], age == 4) %>% dplyr::pull(Num)
               nm.four <- 1-exp(-nat.mort[nat.mort$Year ==yrs[y]-1,][4,]$NM) 
               full.abund[full.abund$Year ==yrs[y]-1,][4,]$Num <- four.abund/(1-nm.four)
             #}# end my 2:0
           } # end if minage ==4
           
            # The minage =3 scenario, goes after 4...
           if(minage >=3)
           {
             # for(my in 0:1)
             # {
               three.abund <- full.abund %>% dplyr::filter(Year == yrs[y], age == 3) %>% dplyr::pull(Num)
               nm.three <- 1-exp(-nat.mort[nat.mort$Year ==yrs[y]-1,][3,]$NM) 
               full.abund[full.abund$Year ==yrs[y]-1,][3,]$Num <- three.abund/(1-nm.three)
             #} # end my 1:0
           } # end if(minage ==2)
                      
           # The minage =2 scenario, this goes last
           if(minage >=2)
           {
             two.abund <- full.abund %>% dplyr::filter(Year == yrs[y], age == 2) %>% dplyr::pull(Num)
             nm.two <- 1-exp(-nat.mort[nat.mort$Year ==yrs[y]-1,][2,]$NM) 
             full.abund[full.abund$Year ==yrs[y]-1,][2,]$Num <- two.abund/(1-nm.two)
           } # end if(minage ==2)
           
           if(minage >=1)
           {
             one.abund <- full.abund %>% dplyr::filter(Year == yrs[y], age == 1) %>% dplyr::pull(Num)
             nm.one <- 1-exp(-nat.mort[nat.mort$Year ==yrs[y]-1,][1,]$NM) 
             full.abund[full.abund$Year ==yrs[y]-1,][1,]$Num <- one.abund/(1-nm.one)
           } # end if(minage ==2)
      
         } # The annoying if to fill in rest of the first few years.
  } # end if minage > 0
 
  # We won't have a weight at age for the young ages, which is fine since we only need that for SSB
  weight.age <- ASR_sub %>% dplyr::filter(type=="WA") %>% dplyr::rename(WA=value) %>% dplyr::select(-type)
  removals <- ASR_sub %>% dplyr::filter(type=="Catch") %>% dplyr::rename(Catch=value) %>% dplyr::select(-type)
  # Fill the leading NAs with 0s now...
  if(minage > 0) 
  {
    weight.age$WA[weight.age$age %in% 0:(minage-1)] <- 0
    removals$Catch[removals$age %in% 0:(minage-1)] <- 0
  }
 # if(i=="ICES-WGBFAS_BS 22-32_Sprattus_sprattus") removals$Catch <- removals$Catch/1000
  
  data <- age.mat %>%
    full_join(nat.mort) %>%
    #full_join(abund) %>%
    full_join(full.abund) %>%
    full_join(weight.age) %>%
    full_join(removals)

  # Nice way to toss NAs!
  data$available <- apply(is.na(data[, c("AM", "Num", "WA")]), 1, function(x) all(!x==T))
  data <- data[data$available==T,]
  # And then toss the years we don't have 0 data for Numbers in the 0 age class
  toss.years <- data %>% dplyr::group_by(Year) %>% dplyr::reframe(bad.years = which(min(age)>0))
  data <- data[!data$Year %in% toss.years$Year,]
  
  # Tidy up the data for input...
  data$prop.nat.mort <- 1-exp(-data$NM)
  #prop.nat.mort[,-which(names(prop.nat.mort) %in% c("Year", "Stock", "type"))] <- 1-exp(-prop.nat.mort[,-which(names(prop.nat.mort) %in% c("Year", "Stock", "type"))])

  rem <- data %>% dplyr::group_by(Year,.drop=F) %>% dplyr::summarize(rem=sum(Catch,na.rm=T)) #%>% dplyr::pull(rem)
  
  missing_rem<- NULL
  if(any(is.na(rem$rem))) 
  {
    missing_rem <- unique(data$Year)[which(is.na(rem$rem))]
    rem$rem[is.na(rem$rem)] <- median(rem$rem, na.rm=T)
  }
  
  #rowSums(removals[,-which(names(removals) %in% c("Year", "Stock", "type"))], na.rm=T)
  years <- data %>% dplyr::pull(Year) %>% unique() %>% sort()

  N.end <- sum(data[data$Year==max(years),]$Num)
  all.abund <- data %>% dplyr::group_by(Year) %>% dplyr::summarize(vpa=sum(Num,na.rm=T)) %>% pull(vpa)
  vpa.abund <- data %>% dplyr::group_by(Year) %>% dplyr::filter(age %in% minage:maxage) %>% dplyr::summarize(vpa=sum(Num,na.rm=T)) %>% pull(vpa)
  # The real mx matrix, recruits produced per individual in each age class... Not perfect as I need to offset recruits/ssb, but close enough for the moment..
 
  #recruits
  annual <- data.frame(Year=data$Year[data$age==0], recruits=data$Num[data$age==0])
  #ssn
  data$ssn <- data$Num * data$AM
  #ssb
  data$ssb <- data$ssn * data$WA #I need to figure out how to line this up with the number of recruits for the right years in the data object.... got it right for the overall r.p.ssb below.
  #tot.ssb
  annual <- data %>% group_by(Year) %>% summarize(tot.ssb = sum(ssb)) %>% left_join(annual)
  
  #tst <- data %>% group_by(Year) %>% summarize(tot.ssn = sum(ssn)) %>% left_join(annual)

  #r.p.ssb So we are assuming the SSB in year X produces the observed recruits in year X
  annual$r.p.ssb <- annual$recruits/annual$tot.ssb
  # recs.per.age
  data <- left_join(data, annual)
  # So I need to make an offset SSB in the 'data' object to line up with the correct r.p.ssb field.  This is probably gonna suck...
  # tmp <- NULL
  # for(j in 1:length(years))
  # {
  #   tst <- data %>% dplyr::filter(Year == years[j]) %>% dplyr::select(ssb,ssn,Year,age)
  #   tst$Year <- tst$Year + minage
  #   names(tst) <- c("ssb.offset","ssn.offset","Year","age")
  #   tmp[[j]] <- tst
  # }
  # Unpack the list
  #@ssb.off <- do.call('rbind',tmp)
  # And merge it with the data object
  #data <- left_join(data,ssb.off,by=c("Year","age"))
  data$recs.per.age <- data$ssb*data$r.p.ssb
  # mx
  # Some of the stocks are just the males and females, so these are already half the population.  Probably can just not include the male stocks in the end.
  # The demographic models are 'female' only, so we'd want to divide the number of recruits by 2 and the SSN by 2, but that just cancels out
  # so there is no need to make the mom adjustment.
  data$mx <- data$recs.per.age/data$ssn # if(grepl("males",i))
  # if(!grepl("males",i))data$mx <- data$recs.per.age/data$ssn/2 # Moms only! 
  data$mx[is.nan(data$mx)] <- 0 # if we don't have any spawners in an age class in a year their fecundity is 0
  # Now for the very high recruitment years allow for a small amount of recruitment (20% of the lowest age) in the age classes after year 0....
  
  # if(length(high.rec.years) > 0)
  # {
  #   for(y in high.rec.years)
  #   {
  #     tmp <- data$AM[data$Year == y]
  #     am.fill <- which(tmp ==0) 
  #     if(length(am.fill) > 1) data$mx[data$Year == y-1][am.fill[-1]] <- 0.2*min(data$mx[data$Year == y & data$mx > 0],na.rm=T)
  #   }
  # }
  
  age.mat <- data %>% dplyr::select("Year", "age", "AM") %>% pivot_wider(names_from=age, values_from = AM) %>% dplyr::select(-Year)
  prop.nat.mort <- data %>% dplyr::select("Year", "age", "prop.nat.mort") %>% pivot_wider(names_from=age, values_from = prop.nat.mort) %>% dplyr::select(-Year) %>% as.data.frame
  weight.age <- data %>% dplyr::select("Year", "age", "WA") %>% pivot_wider(names_from=age, values_from = WA) %>% dplyr::select(-Year)
  mx <- data %>% dplyr::select("Year", "age", "mx") %>% pivot_wider(names_from=age, values_from = mx) %>% dplyr::select(-Year) %>% as.data.frame()
  abund.age <- data %>% dplyr::select("Year", "age", "Num") %>% pivot_wider(names_from=age, values_from = Num) %>% dplyr::select(-Year) %>% as.data.frame()
  # Now we can save out the catch and get an instantaneous F
  data$Catch[is.na(data$Catch)] <- 0
  data$Exp <- data$Catch/data$Num
  # If it is exactly 1 that leads to an Inf, which is annoying, so make it 1.1 and fix it with the rest below
  data$Exp[data$Exp == 1] <- 1.1
  # And make this an F
  data$Fs <- -log(1-data$Exp)
  if(any(is.na(data$Fs)))
  {
    fixers <- which(is.na(data$Fs))
    print(paste0("Had to replace ",length(fixers), ' exploitation rates for stock ',i))
    for(f in fixers)
    {
      yr <- data$Year[f]
      fs <- max(data$Fs[data$Year == yr],na.rm=T)
      data$Fs[f] <- fs
      data$Exp[f] <- 1-exp(-fs)
    }
  }
  
  full.rems <- data %>% dplyr::select("Year", "age", "Catch") %>% pivot_wider(names_from=age, values_from = Catch) %>% dplyr::select(-Year)
  full.Fs <-  data %>% dplyr::select("Year", "age", "Fs") %>% pivot_wider(names_from=age, values_from = Fs) %>% dplyr::select(-Year)
  
  
  if(i == "DFO_2J3KL_Gadus_morhua")
  {
    age.mat[,10:12] <- 1
    prop.nat.mort[,10:12] <- prop.nat.mort[,9]
    weight.age[12:14,11:12] <- weight.age[12:14,10]
    weight.age[15,12] <- weight.age[15,11]
    mx[12:14,11:12] <- mx[12:14,10]
    mx[15,12] <- mx[15,11]
    full.Fs[12:14,11:12] <- full.Fs[12:14,10]
    full.Fs[15,12] <- full.Fs[15,11]
    abund.age[12:14,11:12] <- abund.age[12:14,10]
    abund.age[15,12] <- abund.age[15,11]
    # I could calculate, but this will get us to the same place...
    full.rems[12:14,11:12] <- full.rems[12:14,10]
    full.rems[15,12] <- full.rems[15,11]
  }
  
  if(i == "DFO_4T-Spring_Clupea_harengus")
  {
    age.mat[6:7,12] <- 1
    prop.nat.mort[6:7,12] <- prop.nat.mort[6:7,11]
    weight.age[6:7,12] <- weight.age[6:7,11]
    mx[6:7,12] <- mx[6:7,11]
    full.Fs[6:7,12] <- full.Fs[6:7,11]
    abund.age[6:7,12] <- abund.age[6:7,11]
    full.rems[6:7,12] <- full.rems[6:7,11]
  }
  
  if(i == "ICES-HAWG_CS 6a- 7b-7c_Clupea_harengus") 
  {
    age.mat[30,9] <- 1
    prop.nat.mort[30,9] <- prop.nat.mort[30,8]
    weight.age[30,9] <- weight.age[29,9]
    mx[30,9] <- mx[30,8]
    full.Fs[30,9] <- full.Fs[30,8]
    abund.age[30,9] <- abund.age[30,8]
    full.rems[30,9] <- full.rems[30,8]
  }
  
  if(i == "ICES-WGCSE_IS6a-7b-7j_Dicentrarchus _labrax")
  {
    age.mat[c(14,27,40),7] <- age.mat[1,7]
    prop.nat.mort[c(14,27,40),7] <- prop.nat.mort[1,7]
    weight.age[c(14,27,40),7] <- weight.age[c(13,26,39),7]
    mx[c(14,27,40),7] <- mx[c(14,27,40),6]
    full.Fs[c(14,27,40),7] <- full.Fs[c(14,27,40),6]
    abund.age[c(14,27,40),7] <- abund.age[c(14,27,40),6]
    full.rems[c(14,27,40),7] <- full.rems[c(14,27,40),6]
  }
  # Clear out some 0's...
  if( i == "AFSC_EEBSAI_Limanda_aspera")
  {
    mx[4,19] <- mean(unlist(mx[4,c(18,20)]))
    mx[c(5,7),20] <- mx[c(5,7),19]
    mx[1:6,21] <- mx[1:6,20] 
  }
  # For the years of mx without SSB info to inform them
  # if(minage >0 ) 
  # {
  #   mx.fill <- as.data.frame(matrix(rep(colMeans(mx,na.rm=T),minage),nrow=minage,byrow=T),colnames = names(mx))
  #   names(mx) <- names(mx.fill)
  #  # mx <- rbind(mx[(minage+1):nrow(mx),],mx.fill) # or is it
  #   mx <- rbind(mx.fill,mx[(minage+1):nrow(mx),]) # I think this is right!
  # }
  years.tmp[[i]] <- years
  pnm.tmp[[i]] <- prop.nat.mort
  waa.tmp[[i]] <- weight.age
  ages.tmp[[i]] <- minage:maxage
  rem.tmp[[i]] <- rem
  mx.tmp[[i]] <- mx
  NE.tmp[[i]] <- N.end
  vpa.tmp[[i]] <- vpa.abund
  all.abund.tmp[[i]] <- all.abund
  full.abund.tmp[[i]] <- abund.age
  am.tmp[[i]] <- age.mat
  mr.tmp[[i]] <- missing_rem
  fs.tmp[[i]] <- full.Fs
  full.rem.tmp[[i]] <- full.rems
} #end input data loop

save(years.tmp,pnm.tmp,waa.tmp,ages.tmp,rem.tmp,mx.tmp,NE.tmp,vpa.tmp,mr.tmp,am.tmp,Stocks,ASR_stocks,ASR_long,all.abund.tmp,full.abund.tmp,fs.tmp,full.rem.tmp,file =  paste0(loc,"/Results/model_inputs_all_ages.Rdata"))

```

 
So now I can try to do some tuning, both forwards and backwards, lets see what we get from that...

```{r tunes}


########################## Now run the tuning sims
#


load(file = paste0(loc,"/Results/model_inputs_all_ages.Rdata"))


#DK PICK IT UP HERE#
# OK So the problem isn't so much "high" recruitment events, it's years in which the population abundance jumps like crash, Stock 57 (ICES Haddock NS)
# Is the best example, look at year 2005, it isn't a outlier in terms of numbers of recruits, but the population jump from 2004 to 2005 is huge and
# thus it's those years that get us the crazy fecundity numbers, which can easily be ameliorated by having a small fecundity in the age classes
# that aren't supposed to be mature yet.  Of course, is that BS, maybe!!  Ended the night running all the stocks trying to see what the changes so far brought about.

back.tune.all.res <- NULL
back.tune.summary <- NULL
for.tune.all.res <- NULL
for.tune.summary <- NULL
for(i in Stocks)
{
  years <- years.tmp[[i]]
  prop.nat.mort <- pnm.tmp[[i]] 
  #rem <- rem.tmp[[i]] 
  mx <- mx.tmp[[i]] 
  N.end <- NE.tmp[[i]] 
  ages <- ages.tmp[[i]]
  vpa.abund <- vpa.tmp[[i]] 
  all.abund <- all.abund.tmp[[i]]
  fs <-fs.tmp[[i]]
  full.rem <- full.rem.tmp[[i]]
  full.abund <- full.abund.tmp[[i]]
  #all.abund <- full.abund.tmp[[i]]
  #N.end <- vpa.abund[length(vpa.abund)]
  #Pick your step size
  ss.size <- 0.01
  sensistive.stocks <- c("ICES-WGNSSK_NS 4-3aN_Trisopterus_esmarkii",
                          "ICES-HAWG_NS_Ammodytes_dubius",
                          "DFO_2J3KL_Gadus_morhua",
                          "DFO_3Pn-4RS_Gadus_morhua",
                          "DFO_4T-4VN_Gadus_morhua",
                          "ICES-WGCSE_IS7a_Gadus_morhua",
                          "ICES-WGCSE_CS7a_Merlangius_merlangus",
                          "ICES-WGNSSK_NS 4-7d,20_Gadus_morhua",
                          "ICES-WGNSSK_NS  4-6a-20_Melanogrammus_aeglefinus",
                          "ICES-WGHANSA_SP8abd_Sardina _pilchardus",
                          "ICES-WGNSSK_NS 4-7d_Merlangius_merlangus",
                          "NEFSC-GARMIII_SNE- MA_Limanda_ferruginea",
                          "NEFSC-GARMIII_MA_Paralichthys_dentatus",
                          "ICES-WGCSE_CS7e-k_Gadus_morhua",
                          "DFO_4T_Scomber_scombrus",
                          "ICES-WGCSE_CS27.6a_Merlangius_merlangus",
                          "ICES-WGBFAS_BS 22-32_Sprattus_sprattus",
                           "AFSC_GOA_Theragra_chalcogramma")
  
  if(i %in% sensistive.stocks) ss.size = ss.size/10

   N.start <- all.abund[1]
   print(i)
   # The fecundities are 
   fast.for.tune <- fast.tunes(years,
                           tuner='fec_nm',
                           step.size = ss.size, 
                           abund.ts = all.abund,
                           ages=ages,
                           nm = -(log(1-prop.nat.mort)),
                           fecund = mx,
                           fm = fs,
                           abund.age = full.abund, 
                           catch.age = full.rem, 
                           N.init = N.start,
                           direction= 'forwards'
                           )
   
   for.tune.all.res[[i]] <- fast.for.tune
   for.tune.tmp <- data.frame(fast.for.tune$res,Stock = i)
   for.tune.summary[[i]] <- for.tune.tmp
   
   N.end <- all.abund[length(all.abund)]
   
   # fast.back.tune <- fast.tunes(years,
   #                         tuner='fm',
   #                         step.size = 0.01, # Make sure n.steps is even please!!
   #                         abund.ts = all.abund,
   #                         ages=ages,
   #                         nm = -(log(1-prop.nat.mort)),
   #                         fecund = mx,
   #                         fm = fs,
   #                         abund.age = full.abund, 
   #                         catch.age = full.rem, 
   #                         N.init = N.end,
   #                         direction= 'backwards'
   #                         )
   # 
   # back.tune.all.res[[i]] <- fast.back.tune
   # back.tune.tmp <- data.frame(fast.back.tune$res,Stock = i)
   # back.tune.summary[[i]] <- back.tune.tmp
   
}





#DFO_2J3KL_Gadus_morhua -27.7984654 2.815738e+08
#ICES-WGCSE_IS6a-7b-7j_Dicentrarchus _labrax -21.6050608
# ICES-WGCSE_IS6a-7b-7j_Dicentrarchus _labrax Lotka error
# ICES-HAWG_CS 6a- 7b-7c_Clupea_harengus # lotka error

# Fixed...
#ICES-HAWG_NS_Ammodytes_dubius Overshoot
# ICES-WGNSSK_NS 4-3aN_Trisopterus_esmarkii  Overshoot
#ICES-WGNSSK_NS 4-7d,20_Gadus_morhua Overshoot
# ICES-WGNSSK_NS  4-6a-20_Melanogrammus_aeglefinus Overshoot
# ICES-WGCSE_ISbc-ek_Melanogrammus_aeglefinus  Overshoot

#saveRDS(for.tune.summary,"D:/Github/ICM/Results/forwards_fully_tuned_summary_z.Rds")
#saveRDS(for.tune.all.res,"D:/Github/ICM/Results/forwards_fully_tuned_all_res_z.Rds")
# saveRDS(for.tune.summary,"D:/Github/ICM/Results/forwards_fully_tuned_summary_nm.Rds")
# saveRDS(for.tune.all.res,"D:/Github/ICM/Results/forwards_fully_tuned_all_res_nm.Rds")
#saveRDS(for.tune.summary,"D:/Github/ICM/Results/forwards_fully_tuned_summary_fm.Rds")
#saveRDS(for.tune.all.res,"D:/Github/ICM/Results/forwards_fully_tuned_all_res_fm.Rds")
saveRDS(for.tune.summary,"D:/Github/ICM/Results/forwards_fully_tuned_summary_fec_nm.Rds")
saveRDS(for.tune.all.res,"D:/Github/ICM/Results/forwards_fully_tuned_all_res_fec_nm.Rds")
# 



```

```{r paper-other-metrics}

# We are now looking at everything, lifetime reproductive success

for.tune.summary <- readRDS("D:/Github/ICM/Results/forwards_fully_tuned_summary_fec_nm.Rds")
for.tune.all <- readRDS("D:/Github/ICM/Results/forwards_fully_tuned_all_res_fec_nm.Rds")


load(file =  paste0(loc,"/Results/model_inputs_all_ages.Rdata"))


# 
# cod <- grep("morhua",names(for.tune.summary))
# haddock <- grep('aeglefinus',names(for.tune.summary))
# herring <- grep("harengus",names(for.tune.summary))
# pollock <- grep("virens",names(for.tune.summary)) 
# sole <- grep("solea",names(for.tune.summary))
# euro.plaice <- grep("platessa",names(for.tune.summary))
# am.plaice <- grep("platessoides",names(for.tune.summary))
# 
# p1.stocks <- sort(c(cod,haddock,herring,pollock,sole,euro.plaice,am.plaice))

Stocks <- names(for.tune.summary)
n.stocks <- length(Stocks)

for.tune.stocks <- NULL
for(i in 1:n.stocks) 
{
  nam <- Stocks[i]
  #  A quick way to get the other potentially interesting info for the stock...
  meta <- ASR_long[ASR_long$Stock == nam,][1,]
  tmp <- for.tune.summary[[nam]]
  tmp$Management   <- meta$Management  
  tmp$Area <- meta$Area
  if(nam == "NEFSC-GARMIII_GB_Gadus_morhua") tmp$Area <- "GB (West)"
  tmp$Order <- meta$Order
  tmp$Family   <- meta$Family  
  tmp$Genus  <- meta$Genus 
  tmp$Species <- meta$Species
  tmp$Model <- meta$Model
  tmp$Meeting_or_reference <- meta$Meeting_or_reference
  tmp$Notes <- meta$Notes
  #tmp$removals.init <- rem.tmp[[nam]]$rem
  for.tune.stocks[[nam]] <- tmp
}

# Now unpack them...
for.tunes <- do.call("rbind",for.tune.stocks)
# Typo clean up...
for.tunes$Species[for.tunes$Species==" harengus"] <- "harengus"
for.tunes$Species[for.tunes$Species=="Aeglefinus"] <- "aeglefinus"
for.tunes$Species[for.tunes$Species=="Solea"] <- "solea"

# What Stocks suck
# sucker.check <- for.tunes %>% dplyr::group_by(Stock) %>% dplyr::summarise(min = min(per.diff,na.rm=T),
#                                                                           max = max(per.diff,na.rm=T))
# View(sucker.check)
# 
# # FM issues are all really related to having very low fishing mortality years...
# # Not really sure how to handle that... maybe an if in the code to make a big jump if model is nowhere on convergence
# # and fishing is < 10% of mean F for the population, that would cover all the problems I'm seeing here.
# # Has years with 0 fishing, need to put in something
# "ICES-WGNSSK_NS4 _Scopthalmus_maximus"
# "ICES-WGNSSK_NS 4-3aN_Trisopterus_esmarkii"
# # Removals so low the step size isn't enough...
# "DFO_3Pn-4RS_Gadus_morhua" # Worked great until the second last year then it did nothing, I think the step size was too small
# "DFO_4T-4VN_Gadus_morhua" # In 1995 it just does nothing, I think because the step size is too small due to super low F.
# "DFO_4T_Hippoglossoides _platessoides"
# "NEFSC-GARMIII_GOM-CHATT_Morone_saxatilis"
# tst <- for.tunes %>% dplyr::filter(Stock == "ICES-HAWG_NS_Ammodytes_dubius")
# 
# # Now what does this look like...
# paper.stocks <- unique(for.tunes$Stock)
# 
# tst <- for.tunes %>% dplyr::group_by(Stock) %>% dplyr::summarise(min = min(per.diff,na.rm=T),
#                                                                  max = max(per.diff, na.rm=T))
# # Now the doubling time simulations for each stock


dt.res <- NULL
for(i in paper.stocks)
{
  try <- for.tunes %>% dplyr::filter(Stock == i)
  double.time <- NA
  pop <- 1000

for(s in 1:100)
{
for(y in 2:100)
{
  lambda <- sample(na.omit(try$lambda),size=1)
  pop[y] <- lambda*pop[y-1]
} # end the years loop
tmp <- which(pop >= 2*pop[1])[1]

if(is.na(tmp)) double.time[s] <- 0
if(!is.na(tmp))double.time[s] <- tmp
} # end sim loop

dt.res[[i]] <- data.frame(dt = double.time,Stock = i,Species = try$Species[1])

} # end Stocks loop

dub.time <- do.call("rbind",dt.res)

# Now to get generation lengths + reproductive rates....
# First I need to get the fecundity and natural mortalities by cohort instead of year.

res.fin <- NULL
res.year.fin <- NULL
for(i in paper.stocks)
{
  tst <- for.tune.all[[i]]
  # Fishing mortality
  fm.org.tmp <- fs.tmp[[i]]
  fm.tmp <- tst$fm.opt
  # fecundity
  fec.tmp <- tst$fecund.opt
  fec.org.tmp <- tst$fecund.org
  # Natural mortality
  m.org.tmp <- exp(-tst$nm.org)
  m.tmp <- exp(-tst$nm.opt)
  # Total mortality
  z.tmp <- exp(-tst$z.opt)
  z.org.tmp <- exp(-tst$nm.org -fm.org.tmp)
  
  ages <- 0:(ncol(fec.tmp)-1)
  n.ages <- length(ages)
  years <- tst$res$year
  n.years <- length(years)
  # Now I need to grab the fecundities and nat morts by cohort
  if(n.years > n.ages)
  {
  res.cohort <- NULL
  res.year <- NULL
  for(y in 1:(n.years-n.ages+1))
  {
    count = 0
    fs <- NA
    lx <- 1
    fs.org <- NA
    lx.org <- 1
    lx.year <- 1
    for(a in 1:n.ages)
    {
    fs[a] <- fec.tmp[y+count,a]  
    fs.org[a] <- fec.org.tmp[y+count,a]  
    if(a > 1) 
    {
      lx[a] <- lx[a-1] * m.tmp[y+count,a]  
      lx.org[a] <- lx.org[a-1]* m.org.tmp[y+count,a]  
      lx.year[a] <- lx.year[a-1] * m.tmp[y,a]
    }  # end the a > 1 if
    count <- count + 1
    }# end the ages loop
    res.cohort[[y]] <- data.frame(mx.opt = fs,lx.opt = lx,mx.org = fs.org,lx.org = lx.org,age = ages,
                           mx.lx.opt = fs*lx,mx.lx.org = fs.org*lx.org,
                           x.mx.lx.opt = fs*lx*ages,x.mx.lx.org = fs.org*lx.org*ages,
                           cohort=years[y],Stock = i)
    
    res.year[[y]] <- data.frame(mx.opt = unlist(fec.tmp[y,]),lx.opt = lx.year,age = ages,
                           mx.lx.opt = unlist(fec.tmp[y,])*lx.year,
                           x.mx.lx.opt = unlist(fec.tmp[y,])*lx.year*ages,
                           year=years[y],Stock = i)

} # end the years loop

# unpack it...
res.fin[[i]] <- do.call('rbind',res.cohort)
res.year.fin[[i]] <- do.call('rbind',res.year)
}  # end if to make sure we have enough data to get the cohort estimates.

}# end the stock loop
res.cohort.final <- do.call('rbind',res.fin)
res.year.final <- do.call('rbind',res.year.fin)

pop.dam <- res.cohort.final %>% dplyr::group_by(cohort,Stock) %>% dplyr::summarise(gen.len.opt = sum(x.mx.lx.opt)/sum(mx.lx.opt),
                                                                gen.len.org = sum(x.mx.lx.org)/sum(mx.lx.org),
                                                                R0.opt = sum(mx.lx.opt),R0.org = sum(mx.lx.org))
pop.dam <- data.frame(pop.dam,Management=NA,Area = NA,Order=NA,
                      Family=NA,Genus=NA,Species=NA,Model=NA,Meeting_or_reference = NA,Notes = NA)

for(i in 1:n.stocks) 
{
  nam <- Stocks[i]
  #  A quick way to get the other potentially interesting info for the stock...
  meta <- ASR_long[ASR_long$Stock == nam,][1,]
  
  pop.dam$Management[pop.dam$Stock == nam]   <- meta$Management  
  pop.dam$Area[pop.dam$Stock == nam] <- meta$Area
  if(nam == "NEFSC-GARMIII_GB_Gadus_morhua") pop.dam$Area[pop.dam$Stock == nam] <- "GB (West)"
  pop.dam$Order[pop.dam$Stock == nam] <- meta$Order
  pop.dam$Family[pop.dam$Stock == nam]   <- meta$Family  
  pop.dam$Genus[pop.dam$Stock == nam]  <- meta$Genus 
  pop.dam$Species[pop.dam$Stock == nam] <- meta$Species
  pop.dam$Model[pop.dam$Stock == nam] <- meta$Model
  pop.dam$Meeting_or_reference[pop.dam$Stock == nam] <- meta$Meeting_or_reference
  pop.dam$Notes[pop.dam$Stock == nam] <- meta$Notes

}

pop.dam$Species[pop.dam$Species==" harengus"] <- "harengus"
pop.dam$Species[pop.dam$Species=="Aeglefinus"] <- "aeglefinus"
pop.dam$Species[pop.dam$Species=="Solea"] <- "solea"



```


```{r simp-figs}



ggplot(for.tunes) + geom_jitter(aes(y=lambda,x=Species,group=Stock,color=Stock)) + scale_y_continuous(name = 'rate of growth (lambda)',breaks = c(-1,-0.5,0,0.5,1:10))

ggplot(for.tunes) + geom_jitter(aes(y=lambda.vpa.init,x=Species)) + scale_y_continuous(name = 'rate of growth (lambda)',breaks = c(-1,-0.5,0,0.5,1:10),limits = c(-1,3))

unique(for.tunes$Species)
windows(11,11)
ggplot(dub.time) + geom_jitter(aes(y=dt,x=Species),alpha=0.05,fill="black",color="black",shape=22) + 
                   scale_y_continuous(name = 'Doubling time (years)',breaks = seq(0,100,by=5))

ggplot(for.tunes) + geom_density(aes(lambda,group=Species,color=Species,fill=Species),alpha = 0.2) + scale_x_continuous(breaks = c(0,0.5,1,2,5,10))

windows(11,11)
ggplot(pop.dam) + geom_boxplot(aes(y=gen.len.opt,x=Species)) + ylab("Generation Length (years)")

#options(scipen=999)
r0.plt <- ggplot(pop.dam) + geom_boxplot(aes(y=R0.opt,x=Area))  + 
                            scale_y_log10(name = "Lifetime Reproductive Output")+#, breaks = c(0.001,0.01,0.05,0.1,0.5,1,5,10,50,100),minor_breaks = NULL) + 
                            facet_wrap(~Species,scales = 'free')+
                            theme(axis.text.x = element_text(angle =45,hjust=1))
save_plot("D:/Github/ICM/Figures/tuned/R0_ignoring_fishing.png",r0.plt,base_width = 8,base_height = 8)

windows(11,11)
r0.ts.plt <- ggplot(pop.dam) + geom_line(aes(y=R0.opt,x=cohort,group=Area,color=Area))  + 
                            scale_y_log10(name = "Lifetime Reproductive Output")+#, breaks = c(0.001,0.01,0.1,1,5,10,50,100),minor_breaks = NULL) + 
                            facet_wrap(~Species,scales = 'free')+
                            theme(axis.text.x = element_text(angle =45,hjust=1))
r0.ts.plt
save_plot("D:/Github/ICM/Figures/tuned/R0_timeseries_ignoring_fishing.png",r0.plt,base_width = 8,base_height = 8)

vickis.cols <- sort(rep(c( "#172582",  "#F8DC91", "#FBB891", "#FB6A01", "#B80000"),3))
linetypes <- rep(c(1,2,4),5)

windows(11,11)
cod.r0.ts.plt <- ggplot(pop.dam %>% dplyr::filter(Species == 'morhua')) + geom_line(aes(y=R0.opt,x=cohort,group=Area,color=Area,linetype=Area),size=1.5)  + 
                            scale_y_log10(name = "Lifetime Reproductive Output", breaks = c(0.001,0.01,0.1,1,5,10,50,100),minor_breaks = NULL) + 
                            scale_color_manual(values = vickis.cols) +
                            scale_linetype_manual(values = linetypes) +
                            theme(legend.key.width  = unit(2, "cm"))
cod.r0.ts.plt
#save_plot("D:/Github/ICM/Figures/tuned/R0_timeseries_ignoring_fishing.png",r0.plt,base_width = 8,base_height = 8)


windows(11,11)
ggplot(pop.dam %>% dplyr::filter(Species =="morhua")) + geom_boxplot(aes(y=R0.opt,x=Area))  + 
                                                        scale_y_log10(name = "Lifetime Reproductive Output",breaks = c(0.001,0.01,0.1,1,5,10,50,100),minor_breaks = NULL) +
                                                        theme(axis.text.x = element_text(angle =45,hjust=1))

# Missing catch questions
# first did we do much to the Fecundity term to get here
quantile(for.tunes$mean.fec/for.tunes$mean.vpa.fec,probs=seq(0.01,1,0.01),na.rm=T)

quantile((for.tunes$removals-for.tunes$removals.init)/for.tunes$removals.init,probs=seq(0.01,1,0.01),na.rm=T)
quantile((for.tunes$mean.nm-for.tunes$mean.vpa.nm)/for.tunes$mean.vpa.nm,probs=seq(0.01,1,0.01),na.rm=T)

for.tunes$excess.catch <- for.tunes$removals-for.tunes$removals.init
for.tunes$per.excess.catch <- 100*((for.tunes$removals-for.tunes$removals.init)/for.tunes$removals.init)

windows(11,11)
bycatch.plt <- ggplot(for.tunes) + geom_boxplot(aes(y=per.excess.catch,x=Species)) + 
                                   ylab("Adjustment to catch (%)") +
                                   theme(axis.text.x = element_text(angle=45,hjust = 1))
                                   
save_plot("D:/Github/ICM/Figures/tuned/Percentage_change_to_bycatch_by_species.png",bycatch.plt,base_width = 8,base_height = 8)
                                   
bycatch.plt.cod <- ggplot(for.tunes %>% dplyr::filter(Species == 'morhua')) + geom_boxplot(aes(y=per.excess.catch,x=Area)) + 
                                                                              ylab("Adjustment to catch (%)") +
                                                                              theme(axis.text.x = element_text(angle=45,hjust = 1))
                                                                              
save_plot("D:/Github/ICM/Figures/tuned/Percentage_change_to_bycatch_by_cod_stock.png",bycatch.plt.cod,base_width = 8,base_height = 8)

bycatch.plt <- ggplot(for.tunes) + geom_boxplot(aes(y=per.excess.catch,x=Area)) + facet_wrap(~Species,scales = 'free_x')
                                   ylab("Adjustment to catch (%)") +
                                   theme(axis.text.x = element_text(angle=45,hjust = 1))

```