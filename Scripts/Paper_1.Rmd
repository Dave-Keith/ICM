---
title: "ICM testing"
output:
  pdf_document: default
  html_document: default
  word_document: 
    #reference_docx: template.docx
editor_options:
  chunk_output_type: console
---

The data is now available to test this on at least 81 stocks.  All of the NE Atlantic stocks (ICES) have been through the QA/QC process and we are happy with those data (Sept 1, 2022).  Let's see if we can get this to work on all the stocks with sufficient data... 

```{r, load-stuff,echo=F, message=F, warning=F, fig.width=6, fig.height=4}
# OK, so using the ICES assessments here's what we get for North Sea cod.
library(readxl)
library(tidyverse)
library(rio)
library(ggthemes)
library(cowplot)
loc <- 'D:/GitHub/ICM'


source(paste0(loc,"/Scripts/functions/backwards_sim.R"))
source(paste0(loc,"/Scripts/functions/tuning_sim.R"))

# Choose 5 ICES stocks that we have the necessary data for
#ASR <- read_xlsx("../Data/ASR_2018.xlsx" sheet = "ICES")
ASR1 <- read.csv(paste0(loc,"/Data/ICM_data_NE_atlantic_stocks.csv"))
ASR <- read.csv(paste0(loc,"/Data/ICM_data_NW_atlantic_stocks.csv"))



ASR <- rbind(ASR1,ASR)
datatypes <- unique(gsub(x = names(ASR), pattern = "[^a-zA-Z]", replacement=""))

# Replace 0's in Num.tot with NA so the rest of this works as Freya designed it to...
ASR$Num.tot[ASR$Num.tot == 0] <- NA
# we want:
# Year, Num, WA, Catch, AM, NM, StockID, Management, Area, Order, Family, Genus, Species
ASRdat <- ASR[,c(grep(x=names(ASR), "Num"),
                 grep(x=names(ASR), "WA"),
                 grep(x=names(ASR), "Catch"),
                 grep(x=names(ASR), "AM"),
                 grep(x=names(ASR), "NM"))]
# Making all the data numeric that should be numeric
ASRdat <- apply(X = ASRdat, 2, as.numeric)
# Getting the species info back
ASRsp <- ASR[, which(!1:length(names(ASR)) %in% grep(x=names(ASR), ".", fixed=T))]
# And binding it all back together
ASR_trim <- cbind(ASRsp, ASRdat)
# need a unique ID for stock
#table(ASR_trim$Management, ASR_trim$Species)
ASR_trim$Stock <- paste0(ASR_trim$Management, "_", ASR_trim$Area, "_", ASR_trim$Genus, "_", ASR_trim$Species)

ASR_long <- ASR_trim %>%
  pivot_longer(!c("Management", "Area", "Order", "Family", "Genus", "Species", "Stock", "Year","Meeting_or_reference","Model","Case","Notes")) %>%
  separate(col=name, into=c("type", "age"), sep = "\\.")

```

```{r, prep-data,echo=F, message=F, warning=F, fig.width=6, fig.height=4}

Stocks <- ASR_long %>%
                    dplyr::filter(!is.na(value)) %>%
                    dplyr::group_by(Stock, type) %>%
                    dplyr::summarize(count=length(unique(value))) %>%
                    dplyr::group_by(Stock) %>%
                    dplyr::summarize(types=length(unique(type))) %>%
                    dplyr::filter(types==5) %>%
                    dplyr::select(Stock)

ASR_stocks <- ASR_long %>%
                        dplyr::filter(Stock %in% Stocks$Stock) %>%
                        dplyr::filter(!is.na(value)) %>%
                        dplyr::arrange(Stock, Year, type, as.numeric(age))

# Stocks <- ASR_stocks %>%
#                       dplyr::group_by(Stock, Species, type) %>%
#                       dplyr::summarize(ages=length(unique(age)),
#                                 years=length(unique(Year))) %>%
#                       dplyr::arrange(-years, -ages) %>%
#                       dplyr::filter(!Species=="morhua") %>%
#                       dplyr::distinct(Stock) %>%
#                       dplyr::pull(Stock)
# 
# print(Stocks)
Stocks <- Stocks$Stock

# Going to remove Sebastes norvegicus because we can't get fecundity as the only data we have is total numbers.
#Stocks <- Stocks[Stocks != "ICES-AFWG_DEEP1-2_Sebastes_norvegicus"]
# Esmarki doesn't work great as it is assessed using a quarterly modle.
#Stocks <- Stocks[Stocks != "ICES-WGNSSK_NS 4-3aN_Trisopterus_esmarkii"]

years.tmp <- NULL
pnm.tmp <- NULL
waa.tmp <- NULL
ages.tmp <- NULL
rem.tmp <- NULL
mx.tmp <- NULL
NE.tmp <- NULL
vpa.tmp <- NULL
am.tmp <- NULL
mr.tmp <- NULL
for(i in Stocks)
{
  print(i)
  ASR_sub <- ASR_long %>%
    dplyr::select(Year, Stock, type, age, value) %>%
    dplyr::filter(Stock==i)

  # maxage <- max(as.numeric(ASR_sub$age[!is.na(ASR_sub$value)]))
  # maxYear <- max(ASR_sub$Year[!is.na(ASR_sub$value)])
  # minYear <- min(ASR_sub$Year[!is.na(ASR_sub$value)])
  # forplot <- ASR_sub[as.numeric(ASR_sub$age) < (maxage+1) & ASR_sub$Year %in% minYear:maxYear,]
  # 
  # # summary plots
  # print(ggplot() + geom_line(data=forplot, aes(Year, value)) + facet_grid(type~as.numeric(age), scales="free_y") +
  #         geom_vline(data=forplot[is.na(forplot$value),], aes(xintercept=Year), colour="red") + facet_grid(type~as.numeric(age), scales="free_y") +
  #         theme_bw() + 
  #         ggtitle(i)
  # )
  
  age.mat <- ASR_sub %>% dplyr::filter(type=="AM") %>% dplyr::rename(AM=value) %>% dplyr::select(-type)
  # All of the age at maturities are NA in 0 and 1 year olds, so make them 0's, do that carefully just
  # in case that changes later...
  am.0s <- length(which((!is.na(age.mat$AM[age.mat$age ==0]))))
  am.1s <- length(which((!is.na(age.mat$AM[age.mat$age ==1]))))
  am.2s <- length(which((!is.na(age.mat$AM[age.mat$age ==2]))))
  if(am.0s == 0) age.mat$AM[age.mat$age ==0] <- 0
  if(am.1s == 0) age.mat$AM[age.mat$age ==1] <- 0
  if(am.2s == 0) age.mat$AM[age.mat$age ==2] <- 0
  
  #if(am.1s | am.0s | am.2s > 0) print("Stop, you need to check the age at maturity for either age 0 or 1 as there is data in there.")
  nat.mort <-  ASR_sub %>% dplyr::filter(type=="NM") %>% dplyr::rename(NM=value) %>% dplyr::select(-type)
  abund <- ASR_sub %>% dplyr::filter(type=="Num") %>% dplyr::rename(Num=value) %>% dplyr::select(-type)
  weight.age <- ASR_sub %>% dplyr::filter(type=="WA") %>% dplyr::rename(WA=value) %>% dplyr::select(-type)
  removals <- ASR_sub %>% dplyr::filter(type=="Catch") %>% dplyr::rename(Catch=value) %>% dplyr::select(-type)

 # if(i=="ICES-WGBFAS_BS 22-32_Sprattus_sprattus") removals$Catch <- removals$Catch/1000
  
  data <- age.mat %>%
    full_join(nat.mort) %>%
    full_join(abund) %>%
    full_join(weight.age) %>%
    full_join(removals)

  # Aahh??  Is this NA dropping useful data, needed to quick fix the age at maturity data...
  data$available <- apply(is.na(data[, c("AM", "Num", "WA")]), 1, function(x) all(!x==T))
  data <- data[data$available==T,]

  # Tidy up the data for input...
  data$prop.nat.mort <- 1-exp(-data$NM)
  #prop.nat.mort[,-which(names(prop.nat.mort) %in% c("Year", "Stock", "type"))] <- 1-exp(-prop.nat.mort[,-which(names(prop.nat.mort) %in% c("Year", "Stock", "type"))])

  rem <- data %>% dplyr::group_by(Year,.drop=F) %>% dplyr::summarize(rem=sum(Catch,na.rm=T)) #%>% dplyr::pull(rem)
  
  missing_rem<- NULL
  if(any(is.na(rem$rem))) 
  {
    missing_rem <- unique(data$Year)[which(is.na(rem$rem))]
    rem$rem[is.na(rem$rem)] <- median(rem$rem, na.rm=T)
  }
  
  #rowSums(removals[,-which(names(removals) %in% c("Year", "Stock", "type"))], na.rm=T)
  years <- data %>% dplyr::pull(Year) %>% unique() %>% sort()
  
  N.end <- sum(data[data$Year==max(years),]$Num)
  vpa.abund <- data %>% dplyr::group_by(Year) %>% dplyr::summarize(vpa=sum(Num,na.rm=T)) %>% pull(vpa)

  # The real mx matrix, recruits produced per individual in each age class... Not perfect as I need to offset recruits/ssb, but close enough for the moment..
  #minage
  minage <- min(as.numeric(data$age))
  #maxage
  maxage <- max(as.numeric(data$age))
  #recruits
  annual <- data.frame(Year=data$Year[data$age==minage], recruits=data$Num[data$age==minage])
  #ssn
  data$ssn <- data$Num * data$AM
  #ssb
  data$ssb <- data$ssn * data$WA #I need to figure out how to line this up with the number of recruits for the right years in the data object.... got it right for the overall r.p.ssb below.
  #tot.ssb
  annual <- data %>% group_by(Year) %>% summarize(tot.ssb = sum(ssb)) %>% left_join(annual)
  
  #tst <- data %>% group_by(Year) %>% summarize(tot.ssn = sum(ssn)) %>% left_join(annual)

  #r.p.ssb This needs to be offset by the age of recruits
  annual$r.p.ssb <- c(rep(NA,minage),annual$recruits[(minage+1):nrow(annual)]/annual$tot.ssb[1:(nrow(annual)-minage)])
  # recs.per.age
  data <- left_join(data, annual)
  # So I need to make an offset SSB in the 'data' object to line up with the correct r.p.ssb field.  This is probably gonna suck...
  tmp <- NULL
  for(j in 1:length(years))
  {
    tst <- data %>% dplyr::filter(Year == years[j]) %>% dplyr::select(ssb,ssn,Year,age)
    tst$Year <- tst$Year + minage
    names(tst) <- c("ssb.offset","ssn.offset","Year","age")
    tmp[[j]] <- tst
  }
  # Unpack the list
  ssb.off <- do.call('rbind',tmp)
  # And merge it with the data object
  data <- left_join(data,ssb.off,by=c("Year","age"))
  data$recs.per.age <- data$ssb.offset*data$r.p.ssb
  # mx
  # Some of the stocks are just the males and females, so these are already half the population.  Probably can just not include the male stocks in the end.
  # This works because 'males' is also in 'females'
  if(grepl("males",i)) data$mx <- data$recs.per.age/data$ssn.offset 
  if(!grepl("males",i))data$mx <- data$recs.per.age/data$ssn.offset/2 # Moms only! 
  data$mx[is.nan(data$mx)] <- 0 # if we don't have any spawners in an age class in a year their fecundity is 0
  # Easier to remove the years where we don't have recs.per.age...
  #data <- data %>% dplyr::filter(Year %in% years[(minage+1):length(years)])
  # Something is wrong with the decline rate method, but the exponential and logistic are working pretty... pretty... pretty good...
  
  age.mat <- data %>% dplyr::select("Year", "age", "AM") %>% pivot_wider(names_from=age, values_from = AM) %>% dplyr::select(-Year)
  prop.nat.mort <- data %>% dplyr::select("Year", "age", "prop.nat.mort") %>% pivot_wider(names_from=age, values_from = prop.nat.mort) %>% dplyr::select(-Year) %>% as.data.frame
  weight.age <- data %>% dplyr::select("Year", "age", "WA") %>% pivot_wider(names_from=age, values_from = WA) %>% dplyr::select(-Year)
  mx <- data %>% dplyr::select("Year", "age", "mx") %>% pivot_wider(names_from=age, values_from = mx) %>% dplyr::select(-Year) %>% as.data.frame()
  
  # Dealing with some annoying NAs...
  if(i == "AFSC_BSAI-Males_Pleuronectes_quadrituberculatus")
  {
    age.mat[length(years),] <- age.mat[length(years)-1,]
    prop.nat.mort[length(years),] <- prop.nat.mort[length(years)-1,]
    weight.age[length(years),] <- weight.age[length(years)-1,]
    mx[length(years),13:23] <- mx[length(years),12]
  }
  
  if(i == "DFO_2J3KL_Gadus_morhua")
  {
    age.mat[,8:10] <- 1
    prop.nat.mort[,8:10] <- prop.nat.mort[,7]
    weight.age[12:14,9:10] <- weight.age[12:14,8]
    weight.age[15,10] <- weight.age[15,9]
    mx[12:16,9:10] <- mx[12:16,8]
    mx[17,10] <- mx[17,9]
  }
  
  if(i == "DFO_4T-Spring_Clupea_harengus")
  {
    age.mat[6:7,10] <- 1
    prop.nat.mort[6:7,10] <- prop.nat.mort[6:7,9]
    weight.age[6:7,10] <- weight.age[6:7,9]
    mx[6:9,10] <- mx[6:9,9]
  }
  
  if(i == "ICES-HAWG_CS 6a- 7b-7c_Clupea_harengus") 
  {
    age.mat[30,8] <- 1
    prop.nat.mort[30,8] <- prop.nat.mort[30,7]
    weight.age[30,8] <- weight.age[29,8]
    mx[30:31,8] <- mx[30:31,9]
  }
  
  if(i == "ICES-WGCSE_IS6a-7b-7j_Dicentrarchus _labrax")
  {
    age.mat[c(14,27,40),5] <- age.mat[1,5]
    prop.nat.mort[c(14,27,40),5] <- prop.nat.mort[1,5]
    weight.age[c(14,27,40),5] <- weight.age[c(13,26,39),5]
    mx[c(14,16,27,29,40,42),5] <- mx[c(14,16,27,29,40,42),6]
  }
  
  # For the years of mx without SSB info to inform them
  if(minage >0 ) 
  {
    mx.fill <- as.data.frame(matrix(rep(colMeans(mx,na.rm=T),minage),nrow=minage,byrow=T),colnames = names(mx))
    names(mx) <- names(mx.fill)
   # mx <- rbind(mx[(minage+1):nrow(mx),],mx.fill) # or is it
    mx <- rbind(mx.fill,mx[(minage+1):nrow(mx),]) # I think this is right!
  }
  years.tmp[[i]] <- years
  pnm.tmp[[i]] <- prop.nat.mort
  waa.tmp[[i]] <- weight.age
  ages.tmp[[i]] <- minage:maxage
  rem.tmp[[i]] <- rem
  mx.tmp[[i]] <- mx
  NE.tmp[[i]] <- N.end
  vpa.tmp[[i]] <- vpa.abund
  am.tmp[[i]] <- age.mat
  mr.tmp[[i]] <- missing_rem
} #end input data loop

save(years.tmp,pnm.tmp,waa.tmp,ages.tmp,rem.tmp,mx.tmp,NE.tmp,vpa.tmp,mr.tmp,am.tmp,Stocks,ASR_stocks,ASR_long,file =  paste0(loc,"/Results/model_inputs.Rdata"))

```

```{r, run-mods,echo=F, message=F, warning=F}

load(file = paste0(loc,"/Results/model_inputs.Rdata"))

back.res <- NULL
back.ts <- NULL
back.ts.quants <- NULL
for.res <- NULL
for.ts <- NULL
for.ts.quants <- NULL
tuned.res <- NULL
for(i in Stocks)
{
  years <- years.tmp[[i]]
  prop.nat.mort <- pnm.tmp[[i]] 
  weight.age <- waa.tmp[[i]] 
  ages <- ages.tmp[[i]] 
  rem <- rem.tmp[[i]] 
  mx <- mx.tmp[[i]] 
  N.end <- NE.tmp[[i]] 
  vpa.abund <- vpa.tmp[[i]] 
  age.mat <- am.tmp[[i]]
  # 
  # # The first run gives us the mean estimate, I think that's all we need for our first paper
  tst <- back.sim(years,
                 mat.age = age.mat,
                 nm = -(log(1-prop.nat.mort)),
                 w.age = weight.age,
                 ages = ages,
                 rems = rem$rem,
                 fecund = mx,
                 N.end = N.end,
                 pop.model = 'exponential',
                 n.sims = 1)

  #Combine the data
  did.it.work <- data.frame(abund = c(vpa.abund,tst$Pop$abund),years = c(years,tst$Pop$years),sim = c(rep('VPA',length(years)),tst$Pop$sim))
  # Here get the Upper and lower 50% quantiles to make a functional boxplot
  quants <- did.it.work %>% dplyr::filter(sim != "VPA") %>% dplyr::group_by(years) %>% dplyr::summarise(L.50 = quantile(abund,probs=c(0.25)),
                                                                        med = median(abund),
                                                                        U.50 = quantile(abund,probs=c(0.75)))

  back.res[[i]] <- tst
  back.ts[[i]] <- did.it.work
  back.ts.quants[[i]] <- quants


# ################# Now run as a forward simulation
N.start <- vpa.abund[1]

tst <- for.sim(years,
               mat.age = age.mat,
               nm = -(log(1-prop.nat.mort)),
               w.age = weight.age,
               ages = ages,
               rems = rem$rem, # rep(0,nrow(rem)),
               fecund = mx,
               N.start = N.start,
               pop.model = 'exponential',
               n.sims = 1,
               sd.mat = 0,
               sd.nm = 0,
               sd.wt = 0,
               sd.fecund = 0)

  #Combine the data
  did.it.work <- data.frame(abund = c(vpa.abund,tst$Pop$abund),years = c(years,tst$Pop$years),sim = c(rep('VPA',length(years)),tst$Pop$sim))
  # Here get the Upper and lower 50% quantiles to make a functional boxplot
  quants <- did.it.work %>% dplyr::filter(sim != "VPA") %>% dplyr::group_by(years) %>% dplyr::summarise(L.50 = quantile(abund,probs=c(0.25)),
                                                                        med = median(abund),
                                                                        U.50 = quantile(abund,probs=c(0.75)))

  for.res[[i]] <- tst
  for.ts[[i]] <- did.it.work
  for.ts.quants[[i]] <- quants
  
  

} # end i in Stocks look



# Save all these
saveRDS(object = back.res,file = paste0(loc,"/Results/backwards_sim_results_no_error.Rds"))
saveRDS(object = back.ts,file = paste0(loc,"/Results/backwards_sim_ts_summaries_no_error.Rds"))
saveRDS(object = back.ts.quants,file = paste0(loc,"/Results/backwards_sim_ts_quantiles_summaries_no_error.Rds"))
# Forward simulations, just using the 'realization'
saveRDS(object = for.res,file = paste0(loc,"/Results/forwards_sim_results_no_error.Rds"))
saveRDS(object = for.ts,file = paste0(loc,"/Results/forwards_sim_ts_summaries_no_error.Rds"))
saveRDS(object = for.ts.quants,file = paste0(loc,"/Results/forwards_sim_ts_quantiles_summaries_no_error.Rds"))
 
```



```{r}

# Upack the back.res object...

tst.for <- NULL
tst.back <- NULL
count = 0
for(i in Stocks)
{
  count=count+1
  tmp.for <- for.res[[i]]$r %>% dplyr::filter(n.sims==1)
  tmp.for <- data.frame(tmp.for,stock = i,direction = 'forward simulations',id = count)
  tmp.pop.for <- for.res[[i]]$Pop %>% dplyr::filter(sim==1)
  tst.for[[i]] <- left_join(tmp.pop.for,tmp.for,by=c('years'))
  # backwards
  tmp.back <- back.res[[i]]$r %>% dplyr::filter(n.sims==1)
  tmp.back <- data.frame(tmp.back,stock = i,direction = 'backwards simulations',id = count)
  tmp.pop.back <- back.res[[i]]$Pop %>% dplyr::filter(sim==1)
  tst.back[[i]] <- left_join(tmp.pop.back,tmp.back,by=c('years'))
}

fors <- do.call('rbind',tst.for)
fors <- fors[,-4]
backs <- do.call('rbind',tst.back)

exploring <- rbind(fors,backs)
mn.r <- exploring %>% dplyr::group_by(stock,direction,id) %>% dplyr::summarise(r = median(r,na.rm=T),
                                                                  pop.ratio = dplyr::last(abund)/dplyr::first(abund))
windows(11,11)
ggplot(mn.r) + geom_text(aes(r,pop.ratio,label=id)) + scale_y_log10() + facet_wrap(~direction) + xlab("mean instrinc rate of growth (r)") + ylab("N (Final) / N (Initial)")

quantile(mn.r$r,probs = seq(0.01,1,by=0.01),na.rm=T)

```

So now I can try to do some tuning, both forwards and backwards, lets see what we get from that...

```{r tunes}


########################## Now run the tuning sims
#


load(file = paste0(loc,"/Results/model_inputs.Rdata"))

back.res <- NULL
back.ts <- NULL
back.ts.quants <- NULL
for.res <- NULL
for.ts <- NULL
for.ts.quants <- NULL
tuned.res <- NULL
for(i in Stocks)
{
  years <- years.tmp[[i]]
  prop.nat.mort <- pnm.tmp[[i]] 
  weight.age <- waa.tmp[[i]] 
  ages <- ages.tmp[[i]] 
  rem <- rem.tmp[[i]] 
  mx <- mx.tmp[[i]] 
  N.end <- NE.tmp[[i]] 
  vpa.abund <- vpa.tmp[[i]] 
  age.mat <- am.tmp[[i]]
  N.end <- vpa.abund[length(vpa.abund)]
   
   back.tunes <- tune.sim(years,
                          tuner = 'f',
                           n.steps = 250, step.size = 0.2,
                           abund.ts = vpa.abund,
                           mat.age = age.mat,
                           nm = -(log(1-prop.nat.mort)),
                           w.age = weight.age,
                           ages = ages,
                           rems = rem$rem,
                           fecund = mx,
                           N.init = N.end,
                           pop.model = 'exponential',
                           direction='backwards')

   back.tuned.res[[i]] <- back.tunes

   
   N.start <- vpa.abund[1]
   
   for.tunes   <- tune.sim(years,
                           tuner='f',
                           n.steps =250, step.size =0.2,
                           abund.ts = vpa.abund,
                           mat.age = age.mat,
                           nm = -(log(1-prop.nat.mort)),
                           w.age = weight.age,
                           ages = ages,
                           rems = rem$rem,
                           fecund = mx,
                           N.init = N.start,
                           pop.model = 'exponential',
                           direction= 'forwards')

   for.tuned.res[[i]] <- for.tunes
   
}
   
```

