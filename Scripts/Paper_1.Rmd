---
title: "ICM testing"
output:
  pdf_document: default
  html_document: default
  word_document: 
    #reference_docx: template.docx
editor_options:
  chunk_output_type: console
---

The data is now available to test this on at least 81 stocks.  All of the NE Atlantic stocks (ICES) have been through the QA/QC process and we are happy with those data (Sept 1, 2022).  Let's see if we can get this to work on all the stocks with sufficient data... 

```{r, load-stuff,echo=F, message=F, warning=F, fig.width=6, fig.height=4}
# OK, so using the ICES assessments here's what we get for North Sea cod.
library(readxl)
library(tidyverse)
library(rio)
library(ggthemes)
library(cowplot)
loc <- 'D:/GitHub/ICM'

source(paste0(loc,"/Scripts/functions/tuning_sim_fast.R"))

# Choose 5 ICES stocks that we have the necessary data for
#ASR <- read_xlsx("../Data/ASR_2018.xlsx" sheet = "ICES")
ASR1 <- read.csv(paste0(loc,"/Data/ICM_data_NE_atlantic_stocks.csv"))
ASR <- read.csv(paste0(loc,"/Data/ICM_data_NW_atlantic_stocks.csv"))



ASR <- rbind(ASR1,ASR)
datatypes <- unique(gsub(x = names(ASR), pattern = "[^a-zA-Z]", replacement=""))

# Replace 0's in Num.tot with NA so the rest of this works as Freya designed it to...
ASR$Num.tot[ASR$Num.tot == 0] <- NA
# we want:
# Year, Num, WA, Catch, AM, NM, StockID, Management, Area, Order, Family, Genus, Species
ASRdat <- ASR[,c(grep(x=names(ASR), "Num"),
                 grep(x=names(ASR), "WA"),
                 grep(x=names(ASR), "Catch"),
                 grep(x=names(ASR), "AM"),
                 grep(x=names(ASR), "NM"))]
# Making all the data numeric that should be numeric
ASRdat <- apply(X = ASRdat, 2, as.numeric)
# Getting the species info back
ASRsp <- ASR[, which(!1:length(names(ASR)) %in% grep(x=names(ASR), ".", fixed=T))]
# And binding it all back together
ASR_trim <- cbind(ASRsp, ASRdat)
# need a unique ID for stock
#table(ASR_trim$Management, ASR_trim$Species)
ASR_trim$Stock <- paste0(ASR_trim$Management, "_", ASR_trim$Area, "_", ASR_trim$Genus, "_", ASR_trim$Species)

ASR_long <- ASR_trim %>%
  pivot_longer(!c("Management", "Area", "Order", "Family", "Genus", "Species", "Stock", "Year","Meeting_or_reference","Model","Case","Notes")) %>%
  separate(col=name, into=c("type", "age"), sep = "\\.")

```

```{r, prep-data,echo=F, message=F, warning=F, fig.width=6, fig.height=4}

Stocks <- ASR_long %>%
                    dplyr::filter(!is.na(value)) %>%
                    dplyr::group_by(Stock, type) %>%
                    dplyr::summarize(count=length(unique(value))) %>%
                    dplyr::group_by(Stock) %>%
                    dplyr::summarize(types=length(unique(type))) %>%
                    dplyr::filter(types==5) %>%
                    dplyr::select(Stock)

ASR_stocks <- ASR_long %>%
                        dplyr::filter(Stock %in% Stocks$Stock) %>%
                        dplyr::filter(!is.na(value)) %>%
                        dplyr::arrange(Stock, Year, type, as.numeric(age))

# Stocks <- ASR_stocks %>%
#                       dplyr::group_by(Stock, Species, type) %>%
#                       dplyr::summarize(ages=length(unique(age)),
#                                 years=length(unique(Year))) %>%
#                       dplyr::arrange(-years, -ages) %>%
#                       dplyr::filter(!Species=="morhua") %>%
#                       dplyr::distinct(Stock) %>%
#                       dplyr::pull(Stock)
# 
# print(Stocks)
Stocks <- Stocks$Stock

# Going to remove Sebastes norvegicus because we can't get fecundity as the only data we have is total numbers.
#Stocks <- Stocks[Stocks != "ICES-AFWG_DEEP1-2_Sebastes_norvegicus"]
# Esmarki doesn't work great as it is assessed using a quarterly model.
#Stocks <- Stocks[Stocks != "ICES-WGNSSK_NS 4-3aN_Trisopterus_esmarkii"]

years.tmp <- NULL
pnm.tmp <- NULL
waa.tmp <- NULL
ages.tmp <- NULL
rem.tmp <- NULL
mx.tmp <- NULL
NE.tmp <- NULL
vpa.tmp <- NULL
am.tmp <- NULL
mr.tmp <- NULL
all.abund.tmp <- NULL
full.abund.tmp <- NULL
for(i in Stocks)
{
  print(i)
  ASR_sub <- ASR_long %>%
    dplyr::select(Year, Stock, type, age, value) %>%
    dplyr::filter(Stock==i)

  # Drop the NA years....
  if(i == "ICES-NWWG_ICE-Summer_Clupea_harengus") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1986)
  # There's some funkiness going on in the first 7 years of these data, so staring in year 8
  if( i == "ICES-WGNSSK_NS  4-6a-20_Melanogrammus_aeglefinus") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1971)
  if(i == "ICES-NWWG_FA5b_Pollachius_virens") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1982)
  if(i == "ICES-NWWG_FA5a_Pollachius_virens") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1984)
  if(i == "ICES-AFWG_NEA1-2_Pollachius_virens") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1969)
  if(i == "ICES-WGCSE_CS27.6a_Merlangius_merlangus") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1980)
  if(i == "ICES-WGCSE_NS6a_Gadus_morhua") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1980)
  if(i == "ICES-AFWG_COASTNOR 1-2_Gadus_morhua") ASR_sub <- ASR_sub %>% dplyr::filter(Year > 2006)
  if(i == "NEFSC_5Z_Pseudopleuronectes_americanus")ASR_sub <- ASR_sub %>% dplyr::filter(Year > 1982)
  
  # maxage <- max(as.numeric(ASR_sub$age[!is.na(ASR_sub$value)]))
  # maxYear <- max(ASR_sub$Year[!is.na(ASR_sub$value)])
  # minYear <- min(ASR_sub$Year[!is.na(ASR_sub$value)])
  # forplot <- ASR_sub[as.numeric(ASR_sub$age) < (maxage+1) & ASR_sub$Year %in% minYear:maxYear,]
  # 
  # # summary plots
  # print(ggplot() + geom_line(data=forplot, aes(Year, value)) + facet_grid(type~as.numeric(age), scales="free_y") +
  #         geom_vline(data=forplot[is.na(forplot$value),], aes(xintercept=Year), colour="red") + facet_grid(type~as.numeric(age), scales="free_y") +
  #         theme_bw() + 
  #         ggtitle(i)
  # )
  
  age.mat <- ASR_sub %>% dplyr::filter(type=="AM") %>% dplyr::rename(AM=value) %>% dplyr::select(-type)
  # All of the age at maturities are NA in 0 and 1 year olds, so make them 0's, do that carefully just
  # in case that changes later...
  am.0s <- length(which((!is.na(age.mat$AM[age.mat$age ==0]))))
  am.1s <- length(which((!is.na(age.mat$AM[age.mat$age ==1]))))
  am.2s <- length(which((!is.na(age.mat$AM[age.mat$age ==2]))))
  am.3s <- length(which((!is.na(age.mat$AM[age.mat$age ==3]))))
  if(am.0s == 0) age.mat$AM[age.mat$age ==0] <- 0
  if(am.1s == 0) age.mat$AM[age.mat$age ==1] <- 0
  if(am.2s == 0) age.mat$AM[age.mat$age ==2] <- 0
  if(am.3s == 0) age.mat$AM[age.mat$age ==3] <- 0
  
   # Now we can get the abundance from the VPA models
  abund <- ASR_sub %>% dplyr::filter(type=="Num") %>% dplyr::rename(Num=value) %>% dplyr::select(-type)
  
  #if(am.1s | am.0s | am.2s > 0) print("Stop, you need to check the age at maturity for either age 0 or 1 as there is data in there.")
  # Now do something similar for the Natural moralities, but in this case
  # we take the NM of the youngest age class we have information for and back that number up to year 0.
  # DK NOTE:  THIS IS A BIG CHANGE IN DIRECTION FOR THE LOTKA CALCS SO NEED TO NOTE THIS ONE!!
  
  
  nm.tmp <-  ASR_sub %>% dplyr::filter(type=="NM") %>% dplyr::rename(NM=value) %>% dplyr::select(-type)
  #minage
  minage <- min(as.numeric(nm.tmp$age[!is.na(nm.tmp$NM)]))
  if(minage == 0)  nat.mort <- nm.tmp
  # Some specials...
  if(i %in% c("ICES-WGCSE_CS7e-k_Gadus_morhua","ICES-WGCSE_ROCK6b_Melanogrammus_aeglefinus",
              "ICES-WGHANSA_SP8abd_Sardina _pilchardus","ICES-WGWIDE_NEA 1-9,12,14_Micromesistius_poutassou")) minage <- 1
  if(i == "ICES-WGWIDE_NEA 1,2,5,4a,14a_clupea_ harengus") minage <- 2
  #maxage
  maxage <- max(as.numeric(nm.tmp$age[!is.na(nm.tmp$NM)]))
  # Set up the full abundance matrix 
  full.abund <- abund
  # If we need to imput some data run this loop for natural mortality
  if(minage == 0) full.abund <- abund
  

  if(minage > 0)
  {
    yrs <- sort(unique((nm.tmp$Year)))
    nm.res <- NULL
    if(!i %in% c("ICES-WGCSE_CS7e-k_Gadus_morhua","ICES-WGCSE_ROCK6b_Melanogrammus_aeglefinus",
                 "ICES-WGHANSA_SP8abd_Sardina _pilchardus","ICES-WGWIDE_NEA 1,2,5,4a,14a_clupea_ harengus",
                 "ICES-WGWIDE_NEA 1-9,12,14_Micromesistius_poutassou"))
    {
      for(y in 1:(length(yrs)))
      {
        tmp <- nm.tmp %>% dplyr::filter(Year == yrs[y])
        tmp.abund <- abund %>% dplyr::filter(Year == yrs[y])
        min.nm <- tmp$NM[tmp$age == minage]
        tmp$NM[as.numeric(tmp$age) < minage] <- min.nm
        # Now save these mudders...
        nm.res[[y]] <- tmp
      } # end years loop
      nat.mort <- do.call('rbind',nm.res)
    }
  # Now do the same loopiness for abundance
    for(y in length(yrs):2)
    {
      # The minage of the natural mortality is different from minage of the abundance, annoyingly for this stock...
      if(i == "ICES-AFWG_NEA1-2_Gadus_morhua") minage <- 3
      if(i == "ICES-NWWG_ICE-Summer_Clupea_harengus") minage <- 3

      # for(a in (minage-1):0)
      # {
      #   start.abund <- full.abund %>% dplyr::filter(Year == yrs[y], age == a+1) %>% dplyr::pull(Num)
      #   nm.calc <- 1-exp(-nat.mort[nat.mort$Year ==yrs[y]-1,][a+1,]$NM) 
      #   full.abund[full.abund$Year ==yrs[y]-1,][a+1,]$Num <- start.abund/(1-nm.calc)
      # }
        
        #if(minage >1 & y == 1)
        #{
           # The lowest minage =4, This goes first since we go backwards, this gets us age 3 in year 3
           if(minage ==4) 
           {
               four.abund <- full.abund %>% dplyr::filter(Year == yrs[y], age == 4) %>% dplyr::pull(Num)
               nm.four <- 1-exp(-nat.mort[nat.mort$Year ==yrs[y]-1,][4,]$NM) 
               full.abund[full.abund$Year ==yrs[y]-1,][4,]$Num <- four.abund/(1-nm.four)
             #}# end my 2:0
           } # end if minage ==4
           
            # The minage =3 scenario, goes after 4...
           if(minage >=3)
           {
             # for(my in 0:1)
             # {
               three.abund <- full.abund %>% dplyr::filter(Year == yrs[y], age == 3) %>% dplyr::pull(Num)
               nm.three <- 1-exp(-nat.mort[nat.mort$Year ==yrs[y]-1,][3,]$NM) 
               full.abund[full.abund$Year ==yrs[y]-1,][3,]$Num <- three.abund/(1-nm.three)
             #} # end my 1:0
           } # end if(minage ==2)
                      
           # The minage =2 scenario, this goes last
           if(minage >=2)
           {
             two.abund <- full.abund %>% dplyr::filter(Year == yrs[y], age == 2) %>% dplyr::pull(Num)
             nm.two <- 1-exp(-nat.mort[nat.mort$Year ==yrs[y]-1,][2,]$NM) 
             full.abund[full.abund$Year ==yrs[y]-1,][2,]$Num <- two.abund/(1-nm.two)
           } # end if(minage ==2)
           
           if(minage >=1)
           {
             one.abund <- full.abund %>% dplyr::filter(Year == yrs[y], age == 1) %>% dplyr::pull(Num)
             nm.one <- 1-exp(-nat.mort[nat.mort$Year ==yrs[y]-1,][1,]$NM) 
             full.abund[full.abund$Year ==yrs[y]-1,][1,]$Num <- one.abund/(1-nm.one)
           } # end if(minage ==2)
      
         } # The annoying if to fill in rest of the first few years.
  } # end if minage > 0
  
 


  
  # We won't have a weight at age for the young ages, which is fine since we only need that for SSB
  weight.age <- ASR_sub %>% dplyr::filter(type=="WA") %>% dplyr::rename(WA=value) %>% dplyr::select(-type)
  removals <- ASR_sub %>% dplyr::filter(type=="Catch") %>% dplyr::rename(Catch=value) %>% dplyr::select(-type)
  # Fill the leading NAs with 0s now...
  if(minage > 0) 
  {
    weight.age$WA[weight.age$age %in% 0:(minage-1)] <- 0
    removals$Catch[removals$age %in% 0:(minage-1)] <- 0
  }
 # if(i=="ICES-WGBFAS_BS 22-32_Sprattus_sprattus") removals$Catch <- removals$Catch/1000
  
  data <- age.mat %>%
    full_join(nat.mort) %>%
    #full_join(abund) %>%
    full_join(full.abund) %>%
    full_join(weight.age) %>%
    full_join(removals)

  # Nice way to toss NAs!
  data$available <- apply(is.na(data[, c("AM", "Num", "WA")]), 1, function(x) all(!x==T))
  data <- data[data$available==T,]
  # And then toss the years we don't have 0 data for Numbers in the 0 age class
  toss.years <- data %>% dplyr::group_by(Year) %>% dplyr::reframe(bad.years = which(min(age)>0))
  data <- data[!data$Year %in% toss.years$Year,]
  
  # Tidy up the data for input...
  data$prop.nat.mort <- 1-exp(-data$NM)
  #prop.nat.mort[,-which(names(prop.nat.mort) %in% c("Year", "Stock", "type"))] <- 1-exp(-prop.nat.mort[,-which(names(prop.nat.mort) %in% c("Year", "Stock", "type"))])

  rem <- data %>% dplyr::group_by(Year,.drop=F) %>% dplyr::summarize(rem=sum(Catch,na.rm=T)) #%>% dplyr::pull(rem)
  
  missing_rem<- NULL
  if(any(is.na(rem$rem))) 
  {
    missing_rem <- unique(data$Year)[which(is.na(rem$rem))]
    rem$rem[is.na(rem$rem)] <- median(rem$rem, na.rm=T)
  }
  
  #rowSums(removals[,-which(names(removals) %in% c("Year", "Stock", "type"))], na.rm=T)
  years <- data %>% dplyr::pull(Year) %>% unique() %>% sort()
  
  
  N.end <- sum(data[data$Year==max(years),]$Num)
  all.abund <- data %>% dplyr::group_by(Year) %>% dplyr::summarize(vpa=sum(Num,na.rm=T)) %>% pull(vpa)
  vpa.abund <- data %>% dplyr::group_by(Year) %>% dplyr::filter(age >= minage) %>% dplyr::summarize(vpa=sum(Num,na.rm=T)) %>% pull(vpa)
  # The real mx matrix, recruits produced per individual in each age class... Not perfect as I need to offset recruits/ssb, but close enough for the moment..
 
  #recruits
  annual <- data.frame(Year=data$Year[data$age==0], recruits=data$Num[data$age==0])
  #ssn
  data$ssn <- data$Num * data$AM
  #ssb
  data$ssb <- data$ssn * data$WA #I need to figure out how to line this up with the number of recruits for the right years in the data object.... got it right for the overall r.p.ssb below.
  #tot.ssb
  annual <- data %>% group_by(Year) %>% summarize(tot.ssb = sum(ssb)) %>% left_join(annual)
  
  #tst <- data %>% group_by(Year) %>% summarize(tot.ssn = sum(ssn)) %>% left_join(annual)

  #r.p.ssb This no longer needs any offset...
  annual$r.p.ssb <- annual$recruits/annual$tot.ssb
  # recs.per.age
  data <- left_join(data, annual)
  # So I need to make an offset SSB in the 'data' object to line up with the correct r.p.ssb field.  This is probably gonna suck...
  # tmp <- NULL
  # for(j in 1:length(years))
  # {
  #   tst <- data %>% dplyr::filter(Year == years[j]) %>% dplyr::select(ssb,ssn,Year,age)
  #   tst$Year <- tst$Year + minage
  #   names(tst) <- c("ssb.offset","ssn.offset","Year","age")
  #   tmp[[j]] <- tst
  # }
  # Unpack the list
  #@ssb.off <- do.call('rbind',tmp)
  # And merge it with the data object
  #data <- left_join(data,ssb.off,by=c("Year","age"))
  data$recs.per.age <- data$ssb*data$r.p.ssb
  # mx
  # Some of the stocks are just the males and females, so these are already half the population.  Probably can just not include the male stocks in the end.
  # This works because 'males' is also in 'females'
  if(grepl("males",i)) data$mx <- data$recs.per.age/data$ssn 
  if(!grepl("males",i))data$mx <- data$recs.per.age/data$ssn/2 # Moms only! 
  data$mx[is.nan(data$mx)] <- 0 # if we don't have any spawners in an age class in a year their fecundity is 0
  # Easier to remove the years where we don't have recs.per.age...
  #data <- data %>% dplyr::filter(Year %in% years[(minage+1):length(years)])
  # Something is wrong with the decline rate method, but the exponential and logistic are working pretty... pretty... pretty good...
  
  age.mat <- data %>% dplyr::select("Year", "age", "AM") %>% pivot_wider(names_from=age, values_from = AM) %>% dplyr::select(-Year)
  prop.nat.mort <- data %>% dplyr::select("Year", "age", "prop.nat.mort") %>% pivot_wider(names_from=age, values_from = prop.nat.mort) %>% dplyr::select(-Year) %>% as.data.frame
  weight.age <- data %>% dplyr::select("Year", "age", "WA") %>% pivot_wider(names_from=age, values_from = WA) %>% dplyr::select(-Year)
  mx <- data %>% dplyr::select("Year", "age", "mx") %>% pivot_wider(names_from=age, values_from = mx) %>% dplyr::select(-Year) %>% as.data.frame()
  
  # Dealing with some annoying NAs...
  # if(i == "AFSC_BSAI-Males_Pleuronectes_quadrituberculatus")
  # {
  #   age.mat[length(years),] <- age.mat[length(years)-1,]
  #   prop.nat.mort[length(years),] <- prop.nat.mort[length(years)-1,]
  #   weight.age[length(years),] <- weight.age[length(years)-1,]
  #   mx[length(years),13:23] <- mx[length(years),12]
  # }
  # 
  if(i == "DFO_2J3KL_Gadus_morhua")
  {
    age.mat[,10:12] <- 1
    prop.nat.mort[,10:12] <- prop.nat.mort[,9]
    weight.age[12:14,11:12] <- weight.age[12:14,10]
    weight.age[15,12] <- weight.age[15,11]
    mx[12:14,11:12] <- mx[12:14,10]
    mx[15,12] <- mx[15,11]
  }
  
  if(i == "DFO_4T-Spring_Clupea_harengus")
  {
    age.mat[6:7,12] <- 1
    prop.nat.mort[6:7,12] <- prop.nat.mort[6:7,11]
    weight.age[6:7,12] <- weight.age[6:7,11]
    mx[6:7,12] <- mx[6:7,11]
  }
  
  if(i == "ICES-HAWG_CS 6a- 7b-7c_Clupea_harengus") 
  {
    age.mat[30,9] <- 1
    prop.nat.mort[30,9] <- prop.nat.mort[30,8]
    weight.age[30,9] <- weight.age[29,9]
    mx[30,9] <- mx[30,8]
  }
  
  if(i == "ICES-WGCSE_IS6a-7b-7j_Dicentrarchus _labrax")
  {
    age.mat[c(14,27,40),7] <- age.mat[1,7]
    prop.nat.mort[c(14,27,40),7] <- prop.nat.mort[1,7]
    weight.age[c(14,27,40),7] <- weight.age[c(13,26,39),7]
    mx[c(14,27,40),7] <- mx[c(14,27,40),6]
  }
  # Clear out some 0's...
  if( i == "AFSC_EEBSAI_Limanda_aspera")
  {
    mx[4,19] <- mean(unlist(mx[4,c(18,20)]))
    mx[c(5,7),20] <- mx[c(5,7),19]
    mx[1:6,21] <- mx[1:6,20] 
  }
  # For the years of mx without SSB info to inform them
  # if(minage >0 ) 
  # {
  #   mx.fill <- as.data.frame(matrix(rep(colMeans(mx,na.rm=T),minage),nrow=minage,byrow=T),colnames = names(mx))
  #   names(mx) <- names(mx.fill)
  #  # mx <- rbind(mx[(minage+1):nrow(mx),],mx.fill) # or is it
  #   mx <- rbind(mx.fill,mx[(minage+1):nrow(mx),]) # I think this is right!
  # }
  years.tmp[[i]] <- years
  pnm.tmp[[i]] <- prop.nat.mort
  waa.tmp[[i]] <- weight.age
  ages.tmp[[i]] <- minage:maxage
  rem.tmp[[i]] <- rem
  mx.tmp[[i]] <- mx
  NE.tmp[[i]] <- N.end
  vpa.tmp[[i]] <- vpa.abund
  all.abund.tmp[[i]] <- all.abund
  full.abund.tmp[[i]] <- full.abund
  am.tmp[[i]] <- age.mat
  mr.tmp[[i]] <- missing_rem
} #end input data loop

save(years.tmp,pnm.tmp,waa.tmp,ages.tmp,rem.tmp,mx.tmp,NE.tmp,vpa.tmp,mr.tmp,am.tmp,Stocks,ASR_stocks,ASR_long,all.abund.tmp,full.abund.tmp,file =  paste0(loc,"/Results/model_inputs_all_ages.Rdata"))

```

 
So now I can try to do some tuning, both forwards and backwards, lets see what we get from that...

```{r tunes}


########################## Now run the tuning sims
#


load(file = paste0(loc,"/Results/model_inputs_all_ages.Rdata"))


back.tune.all.res <- NULL
back.tune.summary <- NULL
for.tune.all.res <- NULL
for.tune.summary <- NULL
for(i in Stocks)
{
  years <- years.tmp[[i]]
  prop.nat.mort <- pnm.tmp[[i]] 
  rem <- rem.tmp[[i]] 
  mx <- mx.tmp[[i]] 
  N.end <- NE.tmp[[i]] 
  ages <- ages.tmp[[i]]
  vpa.abund <- vpa.tmp[[i]] 
  all.abund <- all.abund.tmp[[i]]
  #N.end <- vpa.abund[length(vpa.abund)]

   N.start <- all.abund[1]
   print(i)
   # The fecundities are 
   fast.for.tune <- fast.tunes(years,
                           tuner='f',
                           step.size = 0.025, # Make sure n.steps is even please!!
                           abund.ts = all.abund,
                           ages=ages,
                           nm = -(log(1-prop.nat.mort)),
                           rems = rem$rem,
                           fecund = mx,
                           N.init = N.start,
                           direction= 'forwards'
                           )
   
   for.tune.all.res[[i]] <- fast.for.tune
   for.tune.tmp <- data.frame(fast.for.tune$res,Stock = i)
   for.tune.summary[[i]] <- for.tune.tmp
   
   N.end <- all.abund[length(all.abund)]
   
   fast.back.tune <- fast.tunes(years,
                           tuner='f',
                           step.size = 0.025, # Make sure n.steps is even please!!
                           abund.ts = all.abund,
                           ages = ages,
                           nm = -(log(1-prop.nat.mort)),
                           rems = rem$rem,
                           fecund = mx,
                           N.init = N.end,
                           direction= 'backwards'
                           )
   
   back.tune.all.res[[i]] <- fast.back.tune
   back.tune.tmp <- data.frame(fast.back.tune$res,Stock = i)
   back.tune.summary[[i]] <- back.tune.tmp
   
}

tst <- do.call('rbind',for.tune.summary)
quantile(tst$per.diff,probs=seq(0.001,1,0.001),na.rm=T)
# summary(tst$per.diff)
# summary(tst$r)
# tst <- tst[abs(tst$per.diff) > 5,]
# 
# range(tst$per.diff,na.rm=T)
# It completed 33 stocks, was on stock 34
saveRDS(back.tune.summary,"D:/Github/ICM/Results/backwards_fully_tuned_summary.Rds")
saveRDS(for.tune.summary,"D:/Github/ICM/Results/forwards_fully_tuned_summary.Rds")
saveRDS(back.tune.all.res,"D:/Github/ICM/Results/backwards_fully_tuned_all_res.Rds")
saveRDS(for.tune.all.res,"D:/Github/ICM/Results/forwards_fully_tuned_all_res.Rds")

```

